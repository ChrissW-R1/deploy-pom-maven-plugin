package me.chrisswr1.deploypommavenplugin;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import lombok.Getter;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.model.Developer;
import org.apache.maven.model.License;
import org.apache.maven.model.Model;
import org.apache.maven.model.building.ModelBuildingException;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import proguard.annotation.Keep;
import proguard.annotation.KeepName;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@Mojo(
	name = "copy-from-effective",
	defaultPhase = LifecyclePhase.PREPARE_PACKAGE,
	threadSafe = true
)
@Keep
public class CopyFromEffectiveMojo
	extends AbstractMojo {
	@Parameter(
		defaultValue = "${session}",
		readonly = true
	)
	@SuppressFBWarnings(
		value = "EI_EXPOSE_REP",
		justification = "Getter generated by Lombok"
	)
	@Getter
	@KeepName
	private @Nullable MavenSession session;
	@Parameter(
		defaultValue =
			"${project.build.directory}/" +
			"${project.build.finalName}-deploy.pom"
	)
	@Getter
	@KeepName
	private @Nullable File         outputPom;
	@Parameter(
		defaultValue = "false"
	)
	@Getter
	@KeepName
	private           boolean      overwriteWithEffective;
	@Parameter(
		defaultValue = "true"
	)
	@Getter
	@KeepName
	private           boolean      resolveEffectiveElements;
	@Parameter(
		defaultValue = "false"
	)
	@Getter
	@KeepName
	private           boolean      copyEffectiveUrl;
	@Parameter(
		defaultValue = "false"
	)
	@Getter
	@KeepName
	private           boolean      copyEffectiveLicenses;
	@Parameter(
		defaultValue = "false"
	)
	@Getter
	@KeepName
	private           boolean      copyEffectiveDevelopers;

	@Override
	public void execute() throws MojoExecutionException {
		final @Nullable MavenSession session = this.getSession();
		if (session == null) {
			throw new MojoExecutionException("Maven session is not available!");
		}
		final @Nullable MavenProject project = session.getCurrentProject();
		if (project == null) {
			throw new MojoExecutionException("Maven project is not available!");
		}

		final @NotNull Model model;
		try {
			model = PomProcessor.getModel(project.getFile());
		} catch (final @NotNull IOException e) {
			throw new MojoExecutionException(
				"Couldn't read model from POM!",
				e
			);
		}

		boolean       appliedChanges     = false;
		final boolean overwriteEffective = this.isOverwriteWithEffective();
		final @NotNull PropertyProcessor propertyProcessor =
			new PropertyProcessor(session);

		@Nullable String existingUrl = model.getUrl();
		if (
			this.isCopyEffectiveUrl() &&
			(
				existingUrl == null ||
				existingUrl.isEmpty() ||
				overwriteEffective
			)
		) {
			@Nullable String url = project.getUrl();
			if (this.isResolveEffectiveElements()) {
				url = propertyProcessor.resolveString(url);
			}

			if (
				url != null && (!(url.isEmpty())) &&
				(!(url.equalsIgnoreCase(existingUrl)))
			) {
				model.setUrl(url);
				appliedChanges = true;
			}
		}

		@NotNull List<License> existingLicenses = model.getLicenses();
		if (
			this.isCopyEffectiveLicenses() &&
			(
				existingLicenses == null ||
				existingLicenses.isEmpty() ||
				overwriteEffective
			)
		) {
			final @NotNull List<License> licenses;
			if (this.isResolveEffectiveElements()) {
				licenses = new ArrayList<>();
				for (License licenseItem : project.getLicenses()) {
					License license = new License();

					license.setName(propertyProcessor.resolveString(
						licenseItem.getName()
					));
					license.setUrl(propertyProcessor.resolveString(
						licenseItem.getUrl()
					));
					license.setDistribution(propertyProcessor.resolveString(
						licenseItem.getDistribution()
					));

					licenses.add(license);
				}
			} else {
				licenses = project.getLicenses();
			}

			model.setLicenses(licenses);
			appliedChanges = true;
		}

		@NotNull List<Developer> existingDevelopers = model.getDevelopers();
		if (
			this.isCopyEffectiveDevelopers() &&
			(
				existingDevelopers == null ||
				existingDevelopers.isEmpty() ||
				overwriteEffective
			)
		) {
			final @NotNull List<Developer> developers;
			if (this.isResolveEffectiveElements()) {
				developers = new ArrayList<>();
				for (Developer developerItem : project.getDevelopers()) {
					Developer developer = new Developer();

					developer.setName(propertyProcessor.resolveString(
						developerItem.getName()
					));
					developer.setEmail(propertyProcessor.resolveString(
						developerItem.getEmail()
					));
					developer.setOrganization(propertyProcessor.resolveString(
						developerItem.getOrganization()
					));
					developer.setOrganizationUrl(propertyProcessor.resolveString(
						developerItem.getOrganizationUrl()
					));

					developers.add(developer);
				}
			} else {
				developers = project.getDevelopers();
			}

			model.setDevelopers(developers);
			appliedChanges = true;
		}

		if (appliedChanges) {
			try {
				PomProcessor.setModel(this.getOutputPom(), model, project);
			} catch (
				final @NotNull
				IOException |
				ModelBuildingException e
			) {
				throw new MojoExecutionException(
					"Can't write model to output POM!",
					e
				);
			}
		}
	}
}
