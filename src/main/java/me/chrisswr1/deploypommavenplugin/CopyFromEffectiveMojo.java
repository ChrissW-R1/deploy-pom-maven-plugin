package me.chrisswr1.deploypommavenplugin;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import lombok.Getter;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.model.Developer;
import org.apache.maven.model.License;
import org.apache.maven.model.Model;
import org.apache.maven.model.io.xpp3.MavenXpp3Reader;
import org.apache.maven.model.io.xpp3.MavenXpp3Writer;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;
import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import proguard.annotation.Keep;
import proguard.annotation.KeepName;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@Mojo(
	name = "copy-from-effective",
	defaultPhase = LifecyclePhase.PREPARE_PACKAGE,
	threadSafe = true
)
@Keep
public class CopyFromEffectiveMojo
	extends AbstractMojo {
	@Parameter(
		defaultValue = "${session}",
		readonly = true
	)
	@SuppressFBWarnings(
		value = "EI_EXPOSE_REP",
		justification = "Getter generated by Lombok"
	)
	@Getter
	@KeepName
	private @Nullable MavenSession session;
	@Parameter(
		defaultValue =
			"${project.build.directory}/" +
			"${project.build.finalName}-deploy.pom"
	)
	@Getter
	@KeepName
	private @Nullable File         outputPom;
	@Parameter(
		defaultValue = "false"
	)
	@Getter
	@KeepName
	private           boolean      overwriteWithEffective;
	@Parameter(
		defaultValue = "true"
	)
	@Getter
	@KeepName
	private           boolean      resolveEffectiveElements;
	@Parameter(
		defaultValue = "false"
	)
	@Getter
	@KeepName
	private           boolean      copyEffectiveUrl;
	@Parameter(
		defaultValue = "false"
	)
	@Getter
	@KeepName
	private           boolean      copyEffectiveLicenses;
	@Parameter(
		defaultValue = "false"
	)
	@Getter
	@KeepName
	private           boolean      copyEffectiveDevelopers;

	@Override
	public void execute() throws MojoExecutionException {
		final @Nullable MavenSession session = this.getSession();
		if (session == null) {
			throw new MojoExecutionException("Maven session is not available!");
		}
		final @Nullable MavenProject project = session.getCurrentProject();
		if (project == null) {
			throw new MojoExecutionException("Maven project is not available!");
		}

		final @Nullable File inputPom = project.getFile();
		if (inputPom == null || !(inputPom.exists())) {
			this.getLog().error("Couldn't find project POM!");
			return;
		}

		final @NotNull MavenXpp3Reader pomReader = new MavenXpp3Reader();
		final @Nullable Model          model;

		try {
			model = pomReader.read(new FileInputStream(inputPom));

			if (model == null) {
				throw new IOException("Read model is null!");
			}
		} catch (final @NotNull IOException | XmlPullParserException e) {
			this.getLog().error(
				"Can't read model from input POM!",
				e
			);
			return;
		}

		final boolean overwriteEffective = this.isOverwriteWithEffective();
		final @NotNull PropertyProcessor propertyProcessor =
			new PropertyProcessor(session);

		@Nullable String existingUrl = model.getUrl();
		if (
			this.isCopyEffectiveUrl() &&
			(
				existingUrl == null ||
				existingUrl.isEmpty() ||
				overwriteEffective
			)
		) {
			@Nullable String url = project.getUrl();
			if (this.isResolveEffectiveElements()) {
				url = propertyProcessor.resolveString(url);
			}

			model.setUrl(url);
		}

		@NotNull List<License> existingLicenses = model.getLicenses();
		if (
			this.isCopyEffectiveLicenses() &&
			(
				existingLicenses == null ||
				existingLicenses.isEmpty() ||
				overwriteEffective
			)
		) {
			final @NotNull List<License> licenses;
			if (this.isResolveEffectiveElements()) {
				licenses = new ArrayList<>();
				for (License licenseItem : project.getLicenses()) {
					License license = new License();

					license.setName(propertyProcessor.resolveString(
						licenseItem.getName()
					));
					license.setUrl(propertyProcessor.resolveString(
						licenseItem.getUrl()
					));
					license.setDistribution(propertyProcessor.resolveString(
						licenseItem.getDistribution()
					));

					licenses.add(license);
				}
			} else {
				licenses = project.getLicenses();
			}

			model.setLicenses(licenses);
		}

		@NotNull List<Developer> existingDevelopers = model.getDevelopers();
		if (
			this.isCopyEffectiveDevelopers() &&
			(
				existingDevelopers == null ||
				existingDevelopers.isEmpty() ||
				overwriteEffective
			)
		) {
			final @NotNull List<Developer> developers;
			if (this.isResolveEffectiveElements()) {
				developers = new ArrayList<>();
				for (Developer developerItem : project.getDevelopers()) {
					Developer developer = new Developer();

					developer.setName(propertyProcessor.resolveString(
						developerItem.getName()
					));
					developer.setEmail(propertyProcessor.resolveString(
						developerItem.getEmail()
					));
					developer.setOrganization(propertyProcessor.resolveString(
						developerItem.getOrganization()
					));
					developer.setOrganizationUrl(propertyProcessor.resolveString(
						developerItem.getOrganizationUrl()
					));

					developers.add(developer);
				}
			} else {
				developers = project.getDevelopers();
			}

			model.setDevelopers(developers);
		}

		final @Nullable File outputPom = this.getOutputPom();
		if (outputPom == null) {
			this.getLog().info(
				"No output POM specified was specified!"
			);
			return;
		}
		final @NotNull MavenXpp3Writer pomWriter = new MavenXpp3Writer();
		try {
			pomWriter.write(new FileOutputStream(outputPom), model);
		} catch (final @NotNull IOException e) {
			this.getLog().error(
				"Can't write model to output POM!",
				e
			);
			return;
		}

		project.setPomFile(outputPom);
		project.setModel(model);
	}
}
