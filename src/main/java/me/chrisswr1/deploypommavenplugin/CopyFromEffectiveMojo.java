package me.chrisswr1.deploypommavenplugin;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import lombok.Getter;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;
import proguard.annotation.Keep;
import proguard.annotation.KeepName;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.*;
import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.HashSet;
import java.util.Set;

@Mojo(
	name = "copy-from-effective",
	defaultPhase = LifecyclePhase.PREPARE_PACKAGE,
	threadSafe = true
)
@Keep
public class CopyFromEffectiveMojo extends AbstractMojo {
	@Parameter(
		defaultValue = "${session}",
		readonly = true
	)
	@KeepName
	@Nullable
	@SuppressFBWarnings(
		value = "EI_EXPOSE_REP",
		justification = "Getter generated by Lombok"
	)
	@Getter
	private MavenSession session;
	@Parameter(
		defaultValue = "${project.build.directory}/${project.build.finalName}-effective.pom",
		readonly = true
	)
	@KeepName
	@Nullable
	@Getter
	private File effectivePom;
	@Parameter(
		defaultValue = "${project.basedir}/pom.xml",
		readonly = true
	)
	@KeepName
	@Nullable
	@Getter
	private File outputPom;
	@Parameter(
		defaultValue = "${project.build.sourceEncoding}",
		readonly = true
	)
	@KeepName
	@Nullable
	@Getter
	private String charset;
	@Parameter(
		readonly = true
	)
	@KeepName
	@NotNull
	@Getter
	private Set<String> nodes = Set.of(
		"url",
		"licenses",
		"developers"
	);
	@Parameter(readonly = true)
	@KeepName
	@NotNull
	@Getter
	private Set<String> overwriteNodes = Set.of();

	@Override
	public void execute() throws MojoExecutionException {
		final @Nullable MavenSession session = this.getSession();
		if (session == null) {
			throw new MojoExecutionException("Maven session is not available!");
		}
		final @Nullable File effectivePom = this.getEffectivePom();
		if (effectivePom == null || !(effectivePom.exists())) {
			this.getLog().error("Couldn't find effective POM!");
			return;
		}
		final @Nullable File outputPom = this.getOutputPom();
		if (outputPom == null || !(outputPom.exists())) {
			this.getLog().error("Couldn't find output POM!");
			return;
		}
		@Nullable String charset = this.getCharset();
		if (charset == null) {
			charset = "UTF-8";
		}
		final @NotNull Set<String> overwriteNodes = this.getOverwriteNodes();

		final @NotNull String artifactId = session.getCurrentProject().getArtifactId();

		try {
			final @NotNull DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
			factory.setNamespaceAware(false);
			final @NotNull DocumentBuilder builder = factory.newDocumentBuilder();
			final @NotNull XPath xpath = XPathFactory.newInstance().newXPath();
			final @NotNull String xpathExpression = String.format(
				"//project[normalize-space(artifactId)='%s']",
				artifactId
			);
			final @NotNull XPathExpression projectXpath = xpath.compile(xpathExpression);

			final @NotNull Document effectiveDoc = builder.parse(effectivePom);
			final @Nullable Node effectiveProject = (Node)(projectXpath.evaluate(
				effectiveDoc,
				XPathConstants.NODE
			));
			if (effectiveProject == null) {
				this.getLog().error("Effective POM is not valid!");
				return;
			}

			final @NotNull Document outputDoc = builder.parse(outputPom);
			final @Nullable Node outputProject = (Node)(projectXpath.evaluate(
				outputDoc,
				XPathConstants.NODE
			));
			if (outputProject == null) {
				this.getLog().error("Output POM is not valid!");
				return;
			}

			boolean outputChanged = false;
			for (final @Nullable String nodeName : this.getNodes()) {
				if (nodeName == null || nodeName.isEmpty()) {
					continue;
				}

				final @Nullable Node effectiveNode = (Node)(xpath.evaluate(
					nodeName,
					effectiveProject,
					XPathConstants.NODE
				));
				final @Nullable Node importedNode = outputDoc.importNode(
					effectiveNode,
					true
				);

				final @Nullable Node outputNode = (Node)(xpath.evaluate(
					nodeName,
					outputProject,
					XPathConstants.NODE
				));

				if (
					importedNode != null &&
					(overwriteNodes.contains(nodeName) || outputNode == null)
				) {
					outputProject.appendChild(importedNode);
					outputChanged = true;
					this.getLog().info("Added " + nodeName + " from effective POM to output POM.");
				}
			}

			if (outputChanged) {
				final @NotNull Transformer transformer = TransformerFactory.newInstance().newTransformer();
				transformer.setOutputProperty(OutputKeys.INDENT, "yes");
				transformer.setOutputProperty(OutputKeys.ENCODING, charset);
				transformer.transform(new DOMSource(outputDoc), new StreamResult(outputPom));
				this.getLog().info("Output POM formatted.");
			}
		} catch (final @NotNull ParserConfigurationException | SAXException | IOException e) {
			throw new MojoExecutionException("Couldn't parse POM!", e);
		} catch (final @NotNull TransformerException e) {
			throw new MojoExecutionException("Couldn't save output POM!", e);
		} catch (XPathExpressionException e) {
			throw new MojoExecutionException("Couldn't parse xpath to project node!", e);
		}

		try {
			FileProcessor.removeEmptyLines(outputPom, Charset.forName(charset));
		} catch (final @NotNull IOException e) {
			throw new MojoExecutionException("Couldn't remove empty lines from output POM!", e);
		}
	}
}
